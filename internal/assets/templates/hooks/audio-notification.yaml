name: audio-notification
description: Play audio notifications when tasks are completed
event: PostToolUse
matcher: "*"
setup: |
  #!/bin/bash
  # Setup audio notification hook
  
  echo "ðŸ”Š Setting up audio notification hook..."
  
  # Create necessary directories
  mkdir -p .claude/hooks
  mkdir -p .claude/config
  
  # Create the Python hook script
  cat > .claude/hooks/audio-notification.py << 'EOF'
  #!/usr/bin/env python3
  import json
  import sys
  import os
  import subprocess
  import time
  import platform
  
  def get_audio_config():
      """Load audio configuration from config file"""
      config_file = '.claude/config/audio-notification.json'
      if not os.path.exists(config_file):
          return None
          
      try:
          with open(config_file, 'r', encoding='utf-8') as f:
              return json.load(f)
      except Exception as e:
          return None
  
  def should_play_notification(config):
      """Check if we should play a notification based on cooldown"""
      if not config.get('enabled', True):
          return False
          
      cooldown = config.get('cooldown_seconds', 2)
      if cooldown <= 0:
          return True
          
      # Check last notification time
      last_file = '.claude/last-audio-notification'
      if os.path.exists(last_file):
          try:
              with open(last_file, 'r') as f:
                  last_time = float(f.read().strip())
              if time.time() - last_time < cooldown:
                  return False
          except:
              pass
              
      # Update last notification time
      try:
          with open(last_file, 'w') as f:
              f.write(str(time.time()))
      except:
          pass
          
      return True
  
  def get_sound_file(config, tool_result):
      """Determine which sound file to play based on tool result"""
      # Try to determine if operation was successful
      success = True
      try:
          # Check for common error indicators
          if 'error' in str(tool_result).lower():
              success = False
          elif 'failed' in str(tool_result).lower():
              success = False
          elif 'exception' in str(tool_result).lower():
              success = False
      except:
          pass
      
      if success:
          return config.get('success_sound', config.get('default_sound', 'complete.wav'))
      else:
          return config.get('error_sound', config.get('default_sound', 'complete.wav'))
  
  def get_sound_path(sound_file):
      """Get the full path to the sound file"""
      # First check if it's an absolute path
      if os.path.isabs(sound_file):
          return sound_file
          
      # Check in project .claude/sounds directory
      project_sound = os.path.join('.claude', 'sounds', sound_file)
      if os.path.exists(project_sound):
          return project_sound
          
      # Check in embedded sounds directory (relative to hook script)
      script_dir = os.path.dirname(os.path.abspath(__file__))
      embedded_sound = os.path.join(script_dir, '..', 'sounds', sound_file)
      if os.path.exists(embedded_sound):
          return embedded_sound
          
      return None
  
  def play_audio_file(sound_path, volume=70):
      """Play audio file using platform-appropriate command"""
      if not sound_path or not os.path.exists(sound_path):
          return False
          
      try:
          system = platform.system().lower()
          
          if system == 'darwin':  # macOS
              subprocess.run(['afplay', sound_path], 
                           check=False, 
                           stdout=subprocess.DEVNULL, 
                           stderr=subprocess.DEVNULL)
          elif system == 'linux':
              # Try different Linux audio players
              players = ['aplay', 'paplay', 'play']
              for player in players:
                  try:
                      subprocess.run([player, sound_path], 
                                   check=True,
                                   stdout=subprocess.DEVNULL, 
                                   stderr=subprocess.DEVNULL)
                      break
                  except (subprocess.CalledProcessError, FileNotFoundError):
                      continue
          else:  # Windows (assume Git Bash environment)
              # Use PowerShell to play sound
              ps_command = f"(New-Object Media.SoundPlayer '{sound_path}').PlaySync()"
              subprocess.run(['powershell', '-c', ps_command], 
                           check=False,
                           stdout=subprocess.DEVNULL, 
                           stderr=subprocess.DEVNULL)
          return True
      except Exception as e:
          return False
  
  def main():
      try:
          # Load configuration
          config = get_audio_config()
          if not config:
              sys.exit(0)  # No config, exit silently
              
          # Check if notifications should be played
          if not should_play_notification(config):
              sys.exit(0)
              
          # Read tool use data from stdin
          try:
              input_data = json.load(sys.stdin)
          except:
              sys.exit(0)
              
          # Determine appropriate sound
          sound_file = get_sound_file(config, input_data)
          sound_path = get_sound_path(sound_file)
          
          if sound_path:
              volume = config.get('volume', 70)
              play_audio_file(sound_path, volume)
              
      except Exception as e:
          # On any error, fail silently
          pass
      
      sys.exit(0)
  
  if __name__ == '__main__':
      main()
  EOF
  
  # Make the Python script executable
  chmod +x .claude/hooks/audio-notification.py
  
  echo "âœ… Audio notification hook script created successfully!"
command: bash .claude/hooks/run-python.sh .claude/hooks/audio-notification.py
timeout: 5
enabled: true